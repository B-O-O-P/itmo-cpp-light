  ## Домашнее задание 12. STL.
### [Условие](Homework%2012/Условия.md)
### Решения:
* [A](Homework%2012/A.cpp)
* [B](Homework%2012/B.cpp)
* [C](Homework%2012/C.cpp)
* [D](Homework%2012/D.cpp)
* [E](Homework%2012/E.cpp)
* [F](Homework%2012/F.cpp)
* [G](Homework%2012/G.cpp)
* [H](Homework%2012/H.cpp)
* [I](Homework%2012/I.cpp)
* [J](Homework%2012/J.cpp)
* [K](Homework%2012/K.cpp)

  ## Домашнее задание 11. Exceptions.
### Условие:
В стандартной библиотеке есть семейство функций ```to_string``` для преобразования чисел в строки. Однако обратное преобразование не такое удобное — для каждого числового типа есть своя функция (например, ```strtoi``` для ```int```). 
 
В данном задании вам предлагается написать шаблонную функцию ```from_string```, которая умеет преобразовывать строку в разные типы. Для реализации ```from_string``` предлагается воспользоваться классом ```std::istringstream``` который представляет собой поток ввода из строки, т.е. для преобразования строки в тип T предлагается прочитать значение типа T из потока при помощи оператора ```>>```. В случае неудачного преобразования функция должна бросать исключение ```bad_from_string```, класс которого вам нужно реализовать самостоятельно. 
```c++
string s1("123");
int     a1 = from_string<int>   (s1);// a1 = 123
double  b1 = from_string<double>(s1);// b1 = 123.0
string  c1 = from_string<string>(s1);// c1 = "123"

string  s2("12.3");
int     a2 = from_string<int>   (s2);// исключение
double  b2 = from_string<double>(s2);// b2 = 12.3
string  c2 = from_string<string>(s2);// c2 = "12.3"

string  s3("abc");
int     a3 = from_string<int>   (s3);// исключение
double  b3 = from_string<double>(s3);// исключение
string  c3 = from_string<string>(s3);// с3 = "abc"
```
**Указания**:
1. Для того, чтобы учитывать пробельные символы, используйте ```std::noskipws``` (например, если строка с числом начинается с пробела или заканчивается пробелом, то это должно быть ошибкой). 
2. Флаг ```eof()``` у потоков устанавливается только, если не удалось прочитать символ: если при чтении из потока с 5-ю символами прочли 5 символов, но при этом 6-ой (отсутствующий) символ прочесть не пытались, то ```eof()``` будет выдавать ```false```. 
3. Не забудьте определить конструктор ```bad_from_string``` от ```char const *``` или от ```std::string```. 

### Решение: 
* [fromString](Homework%2011/fromString.hpp)
* "Плохой" класс для тестов [header](Homework%2011/BadFromString.h)/[implementation](Homework%2011/BadFromString.hpp)
  
  ## Домашнее задание 10. Metric.
### Условие:
Маршрут – Ломаная на плоскости, соединяющая некоторые данные точки (заказы). 
Необходимо реализовать программу, которая умеет эффективно разбивать заказы на маршруты с ограничениями. Пусть у нас имеется алгоритм, который принимает на вход множество точек, и разбивает их на маршруты. Алгоритму на вход подается ограничение на число заказов в одном маршруте и метрика эффективности маршрута. 
Ваша задача реализовать хотя бы три различных алгоритма разбиения на маршруты, а также хотя бы три метрики эффективности маршрута. Эти объекты, естественно, должны удовлетворять своим интерфейсам.  
Программа при запуске должна запускать ровно один алгоритм ровно с одной метрикой. Должна быть возможность выбрать алгоритм и метрику не пересобирая программу. Точка входа в программу должна быть одна (один исполняемый файл). 


**Hint**: для управления какой алгоритм выбрать можно использовать, например, текстовый файл. 

### [Решение](Homework%2010)
  
  ## Домашнее задание 9. 
### Условие: 
1.  По аналогии с функцией ```printf``` с лекции напишите функцию ```print_values``` с переменным числом аргументов, которая для каждого аргумента выводит его тип и значение в поток ```std::cout```. Функция должна работать с произвольным числом аргументов. Указание: для вывода имени типа нужно использовать ```std::type_info::name```. Например, вызов функции 
```c++
print_values(0, 3.5, "Hello"); 
```
должен вывести на стандартный вывод примерно следующее (таким будет вывод на g++). 
```c++
i: 0
d: 3.5
PKc: Hello
```

2. Реализуйте следующий класс Array: 
```c++
template<class T>
struct Array
{
  explicit Array(size_t size = 0);
  Array(Array const& a);
  Array & operator=(Array const& a);
  ~Array();
  
  size_t size() const;
  T &         operator[](size_t i);
  T const&    operator[](size_t i) const;
  
  // перемещающий конструктор
  // перемающий оператор присваивания
  
private:
  size_t size_;
  T *    data_;
};  
``` 
3. Напишите шаблонную функцию ```to_pair```, которая принимает произвольный ```std::tuple``` и два индекса внутри и возвращает ```std::pair```, содержащий элементы переданного ```std::tuple``` с соответствующими индексами. 
Пример: 
```c++
auto t = std::make_tuple(0, 3.5, "Hello");
std::pair<double, char const *> p = to_pair<1,2>(t);
// p содержит 3.5 и "Hello"
```

**Замечание**: реализация должна работать в рамках стандарта C++11. 

### Решение:
1. [print_values](Homework%209/print_values.hpp)
2. Array [header](Homework%209/Array.h)/[implementation](Homework%209/Array.hpp)
3. [to_pair](Homework%209/to_pair.hpp)
 
  
  ## Домашнее задание 8. Virtual polymorphism.
### Условие:

 1. Предположим, что при разработке игры вам потребовался юнит "Челмедведосвин" (ManBearPig).  Разработайте иерархию классов, реализуйте необходимые конструкторы и добавьте разумные методы. PS: В данном игровом контексте предполагается, что человек — не животное. 
Структуры, которые обязаны присутствовать: ```Unit```, ```Animal```, ```Man```, ```Bear```, ```Pig```

 2. При помощи ```typedef``` определите тип ```ComplexFunction```, который является указателем на функцию, которая принимает ```int``` и указатель на функцию, принимающую ```double``` и возвращающую ```int```, и возвращает указатель на функцию, которая принимает ```char const *``` и возвращает ```int *```. 
 

 3. Напишите возвращающую ```bool``` шаблонную функцию ```compare```, которая принимает две константные ссылки на объекты одного типа и указатель на константный метод этого типа без параметров, который в свою очередь возвращает значение какого-то второго типа. Функция должна сравнивать объекты по значениям, которые для них вернѐт соответствующий метод, и возвращать ```true```, если значение для первого объекта оказалось меньше, чем для второго.
```c++
std::string s1("Elf");
std::string s2("Archer);

// сравнение строк по длине
bool r1 = compare(s1, s2, &std::string::size); // true
bool r2 = compare(s1, s1, &std::string::size); // false
```

 4. Предположим, что вам даётся два указателя на объект некоторого сложного полиморфного класса, который использует множественное наследование. Оба указателя имеют один и тот же тип, но могут ссылаться на разные однотипные базы внутри одного объекта. 
Напишите шаблонную функцию, которая по двум однотипным указателям проверяет, указывают ли они на один объект. 
 ```c++
 template<class T>
 bool isSameObject(T const * p, T const * q)
 ```
 
### Решение:

 1. Unit [header](Homework%208/Unit.h)/[implementation](Homework%208/Unit.cpp), Animal  [header](Homework%208/Animal.h)/[implementation](Homework%208/Animal.cpp), Main [header](Homework%208/Man.h)/[implementation](Homework%208/Man.cpp), Bear [header](Homework%208/Bear.h)/[implementation](Homework%208/Bear.cpp), Pig [header](Homework%208/Pig.h)/[implementation](Homework%208/Pig.cpp), ManBearPig [header](Homework%208/ManBearPig.h)/[implementation](Homework%208/ManBearPig.cpp)
 
 2. typedef [ComplexFunction](Homework%208/main.cpp)
 
 3. [compare](Homework%208/TemplatedCompare.hpp)
 
 4. [isSameObject](Homework%208/isSameObject.hpp)

  ## Домашнее задание 7. Template.
### Условие:
Реализуйте шаблонную версию класса ```Array```, не полагаясь на то, что для типа T определен оператор присваивания и конструктор по умолчанию. Конструктор копирования у типа T есть. 
![Рис. 1](Homework%207/pictures/1.jpg)

Реализуйте шаблонную функцию ```minimum```, которая находит минимальный элемент, который хранится в экземпляре шаблонного класса ```Array```, при этом типовой параметр шаблона Array может быть произвольным. Чтобы сравнивать объекты произвольного типа, на вход функции также будет передаваться компаратор, в качестве компаратора может выступать функция или объект класса с перегруженным оператором "()". Примеры вызова функции ```minimum```: 

```c++
bool less(int a,int b) { return a < b; }
struct Greater { bool operator()(int a, int b) const { return b < a; } };

Array<int> ints(3);
ints[0] = 10;
ints[1] = 2;
ints[2] = 15;
int min = minimum(ints, less);
int max = minimum(ints, Greater());
```

Шаблонный класс ```Array``` может хранить объекты любого типа, для которого определѐн конструктор копирования, в том числе и другой ```Array```, например, ```Array< Array<int> >```. Глубина вложенности может быть произвольной. Напишите шаблонную функцию (или несколько) ```flatten```, которая принимает на вход такой "многомерный" Array неизвестной заранее глубины вложенности и выводит в поток out через пробел все элементы, хранящиеся на самом нижнем уровне. Примеры работы функции ```flatten```: 

```c++
Array<ints> (2, 0);
ints[0] = 10;
ints[1] = 20;
flatten(ints, std::cout);// выводит на экран строку "10 20"

Array< Array<int> > array_of_ints(2, ints);
flatten(array_of_ints, std::cout);// выводит на экран строку "10 20 10 20"

Array<double> doubles(10, 0.0);
flatten(doubles, std::cout);// работать должно не только для типа int
```

**Hint**: шаблонные функции тоже можно перегружать, из нескольких шаблонных функций будет выбрана наиболее специфичная. 
 
 ### Решение:
 
 * [Array.h](Homework%207/Array.h)/[Array.cpp](Homework%207/Array.cpp)
 * "Плохой" класс для тестов [BadClass.h](Homework%207/BadClass.h)/[BadClass.h](Homework%207/BadClass.cpp)
 
  
  ## Домашнее задание 6. Complex.
### Условие:
Придумайте некоторый класс, для которого разумно переопределить все доступные для переопределения операторы в C++. Использовать ```String```, ```BigInt``` и ```Vector``` запрещено. Чем оригинальнее у вас будет класс, тем больше шансов, что вас будут не сильно мучать на сдаче.

Отлично, выбрали, теперь переоределите для него все доступные для переопределения операторы в C++ (кроме операторов работы с памятью).

### Решение:

* [Complex.h](Homework%206/Complex.h)/[Complex.cpp](Homework%206/Complex.cpp)

  
  ## Домашнее задание 5. String.
### Условие:
Cоздадим свой простой аналог стандартного класса ```string``` для удобной работы со строками. 
Начнем мы с написания конструктора. В этой задаче вам требуется реализовать конструктор, который принимает на вход C-style строку, вычисляет ее размер (без учета завершающего 0 символа) и сохраняет его в поле ```size```, кроме того, конструктор должен аллоцировать память достаточную для хранения копии переданной строки (вместе с завершающим 0 символом), копирует переданную строку в выделенную память и сохраняет указатель на начало этой области памяти в поле ```str```. Т.е. в результате работы конструктора в поле ```str``` должен оказаться указатель на C-строку c копией исходной строки, а в поле ```size``` — длина строки без учета завершающего нулевого символа. 


Конструкторов у структуры может быть несколько. Для строки может оказаться полезным заполняющий конструктор (например, чтобы создать строку пробелов). Заполняющий конструктор принимает число и символ, и создает строку с заданным количеством повторений переданного символа. Условия налагаемые на реализацию конструктора те же самые (в поле ```size``` размер без учета завершающего 0 символа, в поле ```str``` C-style строка, т.е. с завершающим 0 символом). Кроме конструктора в этой задаче вам нужно также реализовать и деструктор, который освободит выделенную память. 


Для работы со строками можно придумать множество полезных методов (подумайте, какие методы пригодились бы вам, и чего вам не хватает для их реализации). Примером такого метода может послужить метод ```append``` — он добавляет копию строки-аргумента в конец текущей строки (т.е. в конец строки, у которой он был вызван). 

```c++
String s1("Hello,");
String s2(" world!"); 
 
s1.append(s2); // теперь s1 хранит "Hello, world!"
```
Ваша задача реализовать метод append. 

При выполнении задания будьте аккуратны при работе с памятью — при вызове метода не должно возникать утечек памяти. Кроме того, не забудьте, что ```size``` хранит размер без учета завершающего 0 символа. 
  
Кроме того, ваша реализация должна корректно работать в следующем тесте: 

```c++
String s("Hello");
s.append(s); // теперь s хранит "HelloHello"
```

Добавьте в класс ```String``` реализацию конструктора копирования. Инвариант класса остается тем же (в ```size``` хранится размер строки без завершающего 0 символа, ```str``` указывает на C-style строку, т. е. с завершающим нулевым символом). 
  
Завершите класс ```String```, добавив к нему оператор присваивания. Будьте аккуратны при работе с памятью. Инвариант класса остается тем же (в ```size``` хранится размер строки без завершающего 0 символа, ```str``` указывает на C-style строку, т. е. с завершающим нулевым символом). 

### Решение:

* [String.h](Homework%205/String.h)/[String.cpp](Homework%205/String.cpp)


  ## Домашнее задание 4. CMake.
### Условие:

* Выполните сформулированное ниже задание, используя любую из интегрированных сред разработки. Результатом реализации части a задания должна быть статическая библиотека, а части b — программа, использующая библиотеку. Структура каталога проекта должна быть такой, как изображена на втором рисунке. Настройте проект приложения таким образом, чтобы в модуле ```rational_poly.cpp``` можно было подключать заголовочный файл библиотеки директивой:
![Рис. 1](Homework%204/pictures/1.jpg)

  * a) Операции с рациональными числами: сокращение, сложение, вычитание, умножение, деление, сравнение.
  
  * b) Для заданного многочлена с рациональными коэффициентами:
  ![Полином](Homework%204/pictures/poly.jpg)
  
  и двух чисел ```q_1, q_2 ∈ Q``` определить, какое из значений больше: ```P_n(q1)```  или ```P_n(q2)``` . Вычисление значения многочлена производить по схеме [Горнера](https://ru.wikipedia.org/wiki/Схема_Горнера).

* Требования к реализации: 
  * Реализовать построение вне каталога проекта, устанавливая соответствующие настройки в интегрированной сред 
  * Части a и b задания должны быть оформлены в виде отдельных проектов (располагаться в разных каталогах системы). 
  * Проект библиотеки должен иметь возможность создавать как статический, так и динамический/разделяемый вариант. 
  * Проект библиотеки должен содержать описание целей тестирования и установки. Установка должна поддерживать компоненты для обычного пользователя и для разработчика. 
  * Структура каталога установки должна быть аналогичной структуре, приведённой на рисунке 2
  ![Рис. 2](Homework%204/pictures/2.jpg)
  * Проект библиотеки должен содержать описание интерфейсных настроек, применяемых к зависимым проектам. 
  * Проект приложения должен подключать библиотеку, используя её сценарий, сгенерированный во время установки. Для этого проект приложения должен иметь кэш-настройку, определяющую путь к каталогу установки библиотеки.
  
Проверьте работоспособность собираемой программы для различных доступных операционных систем и компиляторов.  

### Решение:

  * rational_poly [implementation](Homework%204/rational_poly/rational_poly.cpp)/[CMake](Homework%204/rational_poly/CMakeLists.txt)
  * lib_rational [header](Homework%204/lib_rational/lib_rational.h)/[implementation](Homework%204/lib_rational/lib_rational.cpp)/[CMake](Homework%204/lib_rational/CMakeLists.txt)
  * program [CMake](Homework%204/CMakeLists.txt)
  * [bat-файл](Homework%204/build.cmd) для сборки
  
  ## Домашнее задание 3. Makefile.
### Условие:

* Напишите простые файлы  ```hello.cpp```, ```here.cpp```, ```bye.cpp```, ```mylib.h``` . В ```hello.cpp```, функция должна выводить

```c++
"Hello!"
```

В  ```here.cpp``` , другая функция должна выводить 

```c++
"I am here!"
```

Eще одна функция должна выводить 

```c++
"Bye bye!"
```
В  ```bye.cpp```. 

```mylib.h``` должен содержать объявления  всех трех функций 
* Напишите ```main.cpp```, который вызывает все три функции, результатом работы программы является

```c++
"Hello!" 
"I am here!"
"Bye bye!"
```

В файле ```main.cpp``` нет операторов вывода 
* Напишите **Makefile**, который компилирует все файлы  и строит статическую библиотеку ```mylib.a```, содержащую ```hello.cpp```, ```here.cpp```, ```bye.cpp```, но не ```main.cpp```
* Напишите **Makefile**, который компилирует все файлы  и строит динамическую библиотеку с soname библиотеки ```libmylib.so.5.```  Установите  minor версию ```.1``` и релиз ```.10.``` Таким образом вы получите динамическую библиотеку с именем файла ```libmylib.so.5.1.10``` c установленными ```.so ```ссылками 
    
### Решение:
  
   * файлы [hello.cpp](Homework%203/hello.cpp), [here.cpp](Homework%203/here.cpp), [bye.cpp](Homework%203/bye.cpp), [mylib.h](Homework%203/mylib.h).
   
   * [Makefile](Homework%203/MakeStaticLibrary) для **статической** библиотеки.
   
   * [Makefile](Homework%203/MakeDynamicLibrary) для **динамической** библиотеки.
    

## Домашнее задание 2. Class.
### Условие:

  Необходимо **реализовать** класс STUDENT:
  
   **Private members** of class student:
```
 admno                       integer
 sname                       20 character
 eng. math, science          float
 total                       float
 ctotal()                    a function to calculate eng + math + science with float return type. 
``` 
  **Public member** function of class student:
```  
  Takedata()                 Function to accept values for admno, sname, eng, science and invoke ctotal() to calculate total.
  Showdata()                 Function to display all the data members on the screen 
```
  Необходимо реализовать класс REPORT
  
  **Private members** of class report:
```  
  adno                       4 digit admission number
  name                       20 characters
  marks                      an array of 5 floating point values
  average                    average marks obtained
  GETAVG()                   a function to compute the average obtained in five subject
```
  **Public member** function of class report:
```
  READINFO()                 function to accept values for adno, name, marks. Invoke the function GETAVG()   
  DISPLAYINFO()              function to display all data members of report on the screen.   
```

### Решение:

  * Student [header](Homework%202/Student.h)/[implementation](Homework%202/Student.cpp)

  * Report  [header](Homework%202/Report.h)/[implementation](Homework%202/Report.cpp)
 
  ## Домашнее задание 1. Intro.
### Условие:

  * Write  a Program to demonstrate functions.

  * Write  a Program to demonstrate function overloading.

  * Write  a Program to demonstrate default arguments.

  * Write  a Program to demonstrate pass by value, pass by reference and return by reference.

  * Write  a Program to demonstrate classes and objects.

  * Write  a Program to demonstrate  constructors.
  
### [Решение](Homework%201/main.cpp)
